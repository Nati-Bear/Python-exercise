"""
===========================================================================================================================================
Q_NUM 2675
-문제-
문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 
즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. 
S에는 QR Code "alphanumeric" 문자만 들어있다.
-입력-
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 
각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. 
S의 길이는 적어도 1이며, 20글자를 넘지 않는다
-출력-
각 테스트 케이스에 대해 P를 출력한다.
===========================================================================================================================================
"""
t = int(input()) #테스트 개수 입력
for i in range(t):  #입력받은 만큼 반복
    c, word = input().split() #각 문자의 반복횟수와 문자열을 띄어쓰기로 구분하여 입력 받고 각 변수에 저장
    for j in word : #문자열을 문자로 구분하여 각 문자마다 반복
        print(int(c)*j, end = "")#반복횟수만큼 문자 반복,반복 이후 다음 문자의 반복이 이어지게 하기 위해 end 사용
    print()#다음 입력을 구분하기 위해 줄바꿈의 용도로 사용

"""
===========================================================================================================================================
Q_NUM 5355
-문제-
겨울 방학에 달에 다녀온 상근이는 여름 방학 때는 화성에 갔다 올 예정이다. (3996번) 화성에서는 지구와는 조금 다른 연산자 @, %, #을 사용한다. 
@는 3을 곱하고, %는 5를 더하며, #는 7을 빼는 연산자이다. 
따라서, 화성에서는 수학 식의 가장 앞에 수가 하나 있고, 그 다음에는 연산자가 있다.
-입력-
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 다음 줄에는 화성 수학식이 한 줄에 하나씩 주어진다. 
입력으로 주어지는 수는 정수이거나 소수 첫째 자리까지 주어지며, 0 이상 100 이하이다. 연산자는 최대 3개 주어진다.
-출력-
각 테스트 케이스에 대해서, 화성 수학식의 결과를 계산한 다음에, 소수점 둘째 자리까지 출력한다.
===========================================================================================================================================
"""
t = int(input()) #테스트 개수 입력받기
for i in range(t): #입력받은 횟수만큼 반복
    mars = list(map(str,input().split())) #숫자 및 연산자를 입력받고 값을 리스트에 저장, 이때 문자열로 저장하기 위해 map을 활용하여  str로 변환, 띄어쓰기로 입력 구분
    result = float(mars[0]) #mars 리스트의 첫번째 요솟값에 있는 숫자는 연산되어야 하므로 실수형으로 변화
    for i in mars[1:]: #이후 두번째 요솟값부터는 연산자이므로, 두번째 연산자 내에 있는 요솟값을 각각 비교
        if i == "@": #@일때 3곱하기
            result *= 3
        elif i == "%": #%일때 5 더하기
            result += 5
        elif i == "#": # #일때 7빼기
            result -= 7
    
    print("%0.2f" % result) #소수점 둘째 자리까지 출력하므로 %0.2f사용하여 최종 결과 출력

"""
===========================================================================================================================================
Q_NUM 9506
-문제-
어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라고 한다.
예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.
n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라.
-입력-
입력은 테스트 케이스마다 한 줄 간격으로 n이 주어진다. (2 < n < 100,000)
입력의 마지막엔 -1이 주어진다.
-출력-
테스트케이스 마다 한줄에 하나씩 출력해야 한다.
n이 완전수라면, n을 n이 아닌 약수들의 합으로 나타내어 출력한다(예제 출력 참고).
이때, 약수들은 오름차순으로 나열해야 한다.
n이 완전수가 아니라면 n is NOT perfect. 를 출력한다.
===========================================================================================================================================
"""
while(True): #계속 반복
    num = int(input()) #숫자 입력받기
    if (num==-1): #입력이 -1일시 프로그램종료
        break
    else:
        sort = list() #입력받은 숫자의 약수를 저장하기 위한 리스트 생성
        for i in range(1, num + 1): #약수를 모두 구할때 까지 반복
            if((num%i) == 0 and (i<num)): #나머지가 0이고 입력값보다 작은지(같은 값이 약수에 포함되어 추후 덧셈에 포함되는 것 방지를 위해) 판단 후 충족시 리스트에 저장
                sort.append(i) #리스트에 저장
        if(sum(sort)==num): #리스트 내 요솟값 전체합과 입력받은 숫자가 동일한지 판단
            print(str(num) +" = " + " + " .join(map(str, sort))) #동일하므로 숫자 = 약수 + 약수 형태로 출력, 이를 위해 숫자값인 num과 sort의 요솟값을들 str화, 이후 .join을 통해 각 약수 사이에 + 추가
        else: print(str(num)+" is NOT perfect") #조건 만족 안할 시 is NOT perfect 출력

"""
===========================================================================================================================================
Q_NUM 10162
-문제-
3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다.
버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.
냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 
단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 이것을 최소버튼 조작이라고 한다.
만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 
이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다.
-입력-
첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며 그 범위는 1 ≤ T ≤ 10,000 이다.
-출력-
여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다. 
각각의 횟수 사이에는 빈 칸을 둔다. 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다. 
만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다.
===========================================================================================================================================
"""
time = int(input()) #시간 입력받기
a = 0 #a버튼 누른 횟수 초기화
b = 0 #b버튼 누른 횟수 초기화
c = 0 #c버튼 누른 횟수 초기화
if(time%10 == 0): #3개의 버튼으로 초를 맞출 수 있으려면 10으로 나눴을 때 나머지가 없어야함(즉 일의 자리 수가 0이어야 함), 해당 부분 판단
    a = time//300 #시간을 300으로 나눈 몫을 a에 저장 (몫 = a버튼을 누를 횟수)
    time %= 300 #시간을 300으로 나눈 나머지를 time에 리턴하여 저장
    b = time//60 #time을 60으로 나눈 몫을 b에 저장 (몫 = b버튼을 누른 횟수)
    time %= 60 #time을 60으로 나눈 나머지를 time에 리턴하여 저장 (몫 = c버튼을 누른 횟수)
    c = time//10 #time을 10으로 나눈 몫 저장
    print(a, b, c) #a,b,c 버튼들 누른 횟수 출력
else :
    print("-1") #세 버튼으로 시간을 맞출 수 없을 시(일의 자리가 0이 아닐 시) -1 출력

"""
===========================================================================================================================================
Q_NUM 10699
-문제-
서울의 오늘 날짜를 출력하는 프로그램을 작성하시오.
-입력-
입력은 없다.
-출력-
서울의 오늘 날짜를 "YYYY-MM-DD" 형식으로 출력한다.
"""
import time#표준라이브러리의 time 가져오기
print(time.strftime('%Y', time.localtime()) + "-" + time.strftime('%m', time.localtime())+ "-" +time.strftime('%d', time.localtime()))
#time의 strftime의 포맷코드를 사용하여 연도를 yyyy값으로 출력, mm 형식으로 출력, dd 형식으로 출력
"""
===========================================================================================================================================
Q_NUM 11653
-문제-
정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
-입력-
첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
-출력-
N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.
===========================================================================================================================================
"""
num = int(input()) #정수 n 입력받기
i = 2 #소인수분해 시 1은 의미 없으므로 소인수를 2부터 시작, i값의 초기화
while(i<=num): #1과 자기자신만을 약수로 가질 수도 있으므로 i<num, 또한 소인수 분해를 위해 num이 1이 될 때 까지 계속 반복
    if((num%i) == 0): #num이 i로 나눠질시(i가 약수일시)
        print(i) #i값출력
        num /= i #반복을 위해 num값을 i로 나눈 값을 리턴하여 num에 저장
    else:
        i += 1 #i가 num의 약수가 아닐시 약수일때까지 +1 후 나누기 시도를 계속 반복

"""
===========================================================================================================================================
Q_NUM 24262
-문제-
오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.
입력의 크기 n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.
MenOfPassion 알고리즘은 다음과 같다.
MenOfPassion(A[], n) {
    i = ⌊n / 2⌋;
    return A[i]; # 코드1
}
-입력-
첫째 줄에 입력의 크기 n(1 ≤ n ≤ 500,000)이 주어진다.
-출력-
첫째 줄에 코드1 의 수행 횟수를 출력한다.
둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.
===========================================================================================================================================
"""
n = int(input()) #입력의 크기를 받는다
print(1)  #코드1은 무조건 한번만 실행됨 따라서 1 출력
print(0) #한번만 실행되므로 0차식임

"""
===========================================================================================================================================
Q_NUM 2798
-문제-
각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.
이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 
M과 최대한 가깝게 만들어야 한다. N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
-입력-
첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 
이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.
-출력-
첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.
===========================================================================================================================================
"""
n, m = map(int, input().split()) #카드의 개수,숫자m을 입력받아 정수값으로 저장
card = list(map(int, input().split())) #고른 카드에 적힌 수를 리스트에 저장
result = 0 #최종 3장의 합을 저장할 변수 생성 및 초기화
for i in range(n): #첫번째 장을 고르는 경우의 수 n개
    for j in range(i+1, n): #첫번째장을 고른 이후 두번째장을 고르는 경우 : 1번째에 골랐으므로 범위가 i+1~n
        for k in range(j+1, n): #1,2 번째 장을 고른 이후 세번째 장을 고르는 경우의 수 : 1,2 번째를 골랐으므로 범위가 j+1~n
            if(card[i]+card[j]+card[k] > m):  #세장의 합이 m보다 높은 경우 : 조건에 부합하지 않으므로 다시 반복
                continue
            else :
                result = max(result, card[i]+card[j]+card[k]) #조건에 부합하는 경우들 중 세 수의 합이 가장 큰 것을 result에 저장
print(result) #최종결과 출력

"""
===========================================================================================================================================
Q_NUM 19532
-문제-
ax + by = c
dx + ey = f

다음 연립방정식의 해를 구하는 프로그램을 작성하시고
-입력-
정수 a,b,c,d,e,f가 공백으로 구분되어 차례대로 주어진다. (-999 <= a,b,c,d,e,f <= 999$)

문제에서 언급한 방정식을 만족하는 (x,y)가 유일하게 존재하고, 이 때 x와 y가 각각 -999 이상 
999 이하의 정수인 경우만 입력으로 주어짐이 보장된다.
-출력-
문제의 답인 x와 y를 공백으로 구분해 출력한다
===========================================================================================================================================
"""
import math #표준라이브러리 math 호출
a,b,c,d,e,f = map(int,input().split()) #a~f까지의 값을 띄어쓰기로 구분받아 정수값으로 저장
i = math.lcm(a, d) #두식의 x의 계수들의 최소공배수를 math.lcm을 사용하여 구함
r = (c*(i//a))-(f*(i//d)) #이를 통해 가감법을 통해 각 방정식의 결과의 값을 뺄셈하여 r에 저장
j = (b*(i//a))-(e*(i//d)) #같은 방식으로 y의 계수를 j에 저장
y = r//j #결국 식은 j * y = r이 되므로, 이를 이용하여 y값을 구함
x = (c-(b*y))//a #y값을 구하였으므로 이를 이용하여 일차방정식 풀이하여 x값을 구함

print(x, y) #x와 y값을 출력

"""
===========================================================================================================================================
Q_NUM 10815
-문제-
숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때,
이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
-입력-
첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 
숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.
셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 
이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다

-출력-
첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.
===========================================================================================================================================
"""
n = int(input()) #가지고 있는 숫자카드의 개수 입력받기
card = list(map(int,input().split())) #가지고 있는 카드의 정수들을 리스트에 저장
m = int(input()) #구해야할 정수의 개수 입력받기
guess = list(map(int,input().split())) #주어진 정수를 리스트에 저장

for i in range(m): #구해야할 정수 개수 만큼 반복하여 가지고 있는지 아닌지 판단
    if (guess[i] in card): #guess의 요솟값이 가지고 있는 카드에 잇는지 판단, 있을 시 1 출력
        print(1)
    else:
        print(0) #없을 시 0 출력